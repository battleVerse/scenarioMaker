% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/target_track_distance.R
\name{target_track_distance}
\alias{target_track_distance}
\title{Target to sensor track distance}
\usage{
target_track_distance(truthData, sensorData, ownShipData)
}
\arguments{
\item{truthData}{data frame containing all of the truth data for each target (likely from GPS or land-based radar systems). MUST have the following columns:
\itemize{
 \item{time: (double) time of measurement. We currently recommend POSIX}
 \item{lon: (double) longitude of target at time of measurement}
 \item{lat: (double) latitude of target at time of measurement}
 \item{alt: (double) altitude of target at time of measurement}
 \item{truthID: (factor) name or identifier for target. We recommend letters or names}
 \item{heading: (double) target heading in degrees azimuth}
}}

\item{sensorData}{data frame containing each sensor point for all of the tracks. MUST have the following columns:
\itemize{
 \item{time: (double) time of measurement. We currently recommend POSIX}
 \item{lon: (double) longitude of target at time of measurement}
 \item{lat: (double) latitude of target at time of measurement}
 \item{alt: (double) altitude of target at time of measurement}
 \item{trackNum: (factor) identifier for the track. We recommend numbers for each unique track returned by the sensor system}
 }}

\item{ownShipData}{data frame containing all of the truth position of the sensor system (likely from GPS or land-based radar systems). This may be ownship if testing something on a ship or the lat/lon position of a stationary ststem. MUST have the following columns:
\itemize{
 \item{time: (double) time of measurement. We currently recommend POSIX}
 \item{lon: (double) longitude of target at time of measurement}
 \item{lat: (double) latitude of target at time of measurement}
 \item{alt: (double) altitude of target at time of measurement}
 \item{truthID: (factor) name or identifier for target. We recommend letters or names}
 \item{heading: (double) sensor system heading in degrees azimuth}
}}
}
\value{
A dataframe containing all distances, bearings, etc. for every track/target pair. For example, if there were four targets (A through D) and five tracks (1 though 5), then the output contains the distance between target and track for all 20 combinations. The output columns are very similar to that of target_assignment(), however target_assignment() keeps only the target-track pairs that were assigned.

It includes:
\itemize{
  \item{lonError: difference in longitude between the sensor point and target}
  \item{latError: difference in latitude between the sensor point and target}
  \item{altError: difference in altitude between the sensor point and target}
  \item{relBearingToTarget: relative bearing (azimuth) to target from ownship}
  \item{trueBearingToTarget: true bearing (azimuth) to target from ownship}
  \item{trackNum: the track number associated with this target-track pair}
  \item{truthID: the target ID associated with this target-track pair}
  \item{locationError: distance between sensor point and target at the given time}
  \item{pointIndex: index referring to which of the original sensor data points this target-track pair refers. Necessary for comparisons in target_assignment()}
  \item{time: the time that this sensor point was recorded}
  \item{bearingError: difference in calculated bearing between the sensor point and target}
  \item{downrangeError: difference in range to ownship between the sensor point and target}
  \item{lon: longitude of the sensor point}
  \item{lat: latitude of the sensor point}
  \item{alt: altitude of the sensor point}
  \item{rangeToShip: range from target to ownship at the time of the sensor data point}
  \item{targetAspect: target aspect (as seen from ownship) at the time of the sensor data point}
  }
}
\description{
NOTE: This function is called automatically by create_scenario().  If you're using this, you likely want create_scenario() as it runs not only this function but also creates a scenario that can be used in most other functions in this package.  If you're thinking of using this, check out create_scenario() first and make sure that you really want this function.

This function calculates the ranges, bearings, target aspects, and errors associated with every possible target-track pair. It is intended to be used with target_assignment() which will then remove most of these and keep exactly one target per sensor point. This function works as follows:

First, the input is checked using check_input() to make sure that the input data frames are in the correct format. See check_input() for details on this as well as the Input section above for the correct format.

Next, NAUTILUS calculates the disance between each target-track pair. It does this by filtering the truth data to separate each target, calculates all of the desired parameters for the target compared to every sensor track, then repeats this for every target. Ultimately these are combined to one data frame for the output.

It is assumed that the truth data and ownship position will have a measurement frequency equal to or greater than the sensor system. Therefore, to calculate the target-track distance we interpolate the target positions and ownship's position to the time of each sensor point. The lat, lon, and alt positions are interpolated on a spheroidal Earth (WGS84) using the function interp_ellipse().

During this step, Nautilus also interpolates the target and ownship heading to the sensor points. It converts the angle to sin and cos, interpolates those, and then recalculates the angles. It does this to avoid situations when the heading (in azimuth) changes rapidly from 359 degrees back to 0 degrees.

After interpolation, Nautilus then calculates all of the desired output results such as the range between targets and the sensor system and the error (see Output format section above). The range between ownship and the targets is based on the truth data at the time of the sensor point, as are the target bearing and target aspect. It also calculates the difference (error) between each sensor track and each target. Many of these will be removed after the track is assigned to exactly one target in target_assignemnt(), however they are kept in this output.

The distances (ranges) between tracks and targets or targets and ownship is the straight-line distance calculated by converting lon/lat/alt into xyz then taking the square root of the sum of squares. We have written functions that convert lon/lat/alt to xyz and back called lla_to_xyz() and xyz_to_lla().

After the output values for each target-track pair are calculated they are placed into one data frame and returned to the user.

This function does a large number of calculations and is intended to be used in conjunction with target_assignemnt(). All of the target-track combinations are calculated, but in target_assignment() every point of each track will be assigned to a single target. The output of this function can be piped into target_assignment(). It is not recommended that the user use this function as a stand alone function, but rather to always follow it with target_assignment() which assigns each track to a single target.
}
